1. See a YouTube video about Diffie-Hellman key exchange (Done)
2. Extract the common dependency of Crow to an upper directory (Done)
3. Read Wikipedia page about Diffie-Hellman work (Done)
4. Read Diffie-Hellman paper, link: https://www-ee.stanford.edu/~hellman/publications/24.pdf (done)
5. Study and come up with an idea of a protocol between two parties so that they can exchange keys between then (done)

    1. Agreement on Public Parameters: Alice and Bob must agree on a large prime number p (modulus) and a generator g. These are public and can be known by anyone. (setup on this problem)
    * p: A large prime number.
    * g: An integer that is a primitive root modulo p.
    
    2. Private Key Generation:
    * Alice chooses a secret random integer a (her private key), such that 1 < a < p-1.
    * Bob chooses a secret random integer b (his private key), such that 1 < b < p-1.
    Summary of Requisites:
    Randomness: Generated by a CSPRNG.
    Range: 1< a,b < pâˆ’1.
    Bit Length: Sufficiently long (e.g., 256 bits or more for large p).
    Secrecy: Never revealed or transmitted.
    
    3. Public Key Derivation:
    * Alice computes her public key A = g^a mod p.
    * Bob computes his public key B = g^b mod p.
    
    4. Public Key Exchange:
    * Alice sends A to Bob.
    * Bob sends B to Alice. (This exchange happens over an insecure channel.)
    
    5. Shared Secret Computation:
    * Alice computes S = B^a mod p.
    * Bob computes S = A^b mod p.
    
    Since (g^b)^a mod p = (g^a)^b mod p = g^(ab) mod p, both Alice and Bob arrive at the same shared secret S. This S can then be used as a symmetric key or as input to a Key Derivation Function (KDF) to generate session keys.


    5.1. For each party, let then know in advance the agreement on the public parameters, namely: 'p' and 'g' by mean s in this case of a public file.
     
    5.2. Phase 1: Key Exchange (The Core DH Steps)
    This is the interactive part of the protocol.

    Party A (Initiator) Action:

    Choose a cryptographically secure random a.
    Compute A = g^a mod p.
    Send A to Party B.
    Party B (Responder) Action:

    Receive A from Party A.
    Choose a cryptographically secure random b.
    Compute B = g^b mod p.
    Compute shared secret candidate S_B = A^b mod p.
    Send B to Party A.
    Party A (Initiator) Finalization:

    Receive B from Party B.
    Compute shared secret candidate S_A = B^a mod p.
    Verify S_A is non-zero (i.e., not 1). If S_A is 1, it indicates a bad choice of g or a malicious attack aiming to force a trivial shared secret.
    
    5.3. Phase 2: Key Derivation and Confirmation (Crucial for Security)
    The raw shared secret S from DH is just a large number. It should never be used directly as a symmetric encryption key.

    5.4. Key Derivation Function (KDF):

    Both parties use a robust KDF (e.g., HKDF-SHA256, PBKDF2) to derive one or more session keys from the shared secret S, in this case it can be used a SHA256


    Message structure:

    Message 1: Client Hello / Key Exchange (Client to Server)
    This message initiates the key exchange and sends the client's public DH share.

    JSON Structure:
    ```json
    {
    "message_type": "client_hello",
    "protocol_version": "1.0",
    "client_id": "alice_client_123",
    "session_id": "xyz_123_abc",
    "nonce": "some_random_base64_string_from_client",
    "diffie_hellman": {
        "group_name": "rfc3526-group-14",
        "public_key_A": "Hexadecimal_representation_of_A"
    }
    }
    ```

    Field Explanations:

    message_type (string):
    Value: "client_hello"
    Purpose: Clearly identifies what type of message this is. Essential for the receiver to know how to parse and process it.
    
    protocol_version (string):
    Value: "1.0" (or whatever version you define for your protocol)
    Purpose: Allows for future protocol evolution. Receiver can check if it supports this version.
    
    client_id (string, optional):
    Value: A unique identifier for the client (e.g., username, unique device ID).
    Purpose: Helps the server identify who is attempting to connect, useful for logging, session management, or even initial access control.
    
    session_id (string):
    Value: A unique identifier for this specific key exchange session. Could be generated by the client or server.
    Purpose: Links subsequent messages in the same exchange. Important if multiple exchanges happen concurrently.
    
    nonce (string - Base64 encoded):
    Value: A cryptographically secure random string generated by the client for this specific session.
    Purpose:
    
    Contributes to the entropy for key derivation (part of the KDF "salt").
    Helps prevent replay attacks.
    Ensures uniqueness for the session.
    Base64 encoding is common for binary data in JSON.
    
    diffie_hellman (object):
    Purpose: Contains the DH-specific parameters.
    
    group_name (string):
    Value: "rfc3526-group-14" (or "cryptopals-group-33-small" for your problem). This refers to the name field in your public JSON file containing p and g.
    Purpose: Tells the server which predefined p and g group the client intends to use. The server can then look up these parameters from its own copy of the shared JSON file.
    
    public_key_A (string - Hexadecimal):
    Value: The hexadecimal string representation of Alice's computed public key A=g^a(mod p).
    Purpose: This is Alice's DH share that Bob needs to compute the shared secret.

    Software structure: DH class that takes care of setting the private key, public key and setting of the shared secret

6. Read the RFC-3536 More Modular Exponential (MODP) Diffie-Hellman groups for Internet Key Exchange (IKE) to further complete the 
json file dh_parameters.json (Done)

https://datatracker.ietf.org/doc/html/rfc3526

7. Creation of the skeleton for the client and the server to carry out the DH protocol (Done)
    7.1. Migration of the MessageExtractionFacility from the previous problems, to enable the hex to int conversion (Done)
    7.2. Creation of an empty server class (Done)
    7.3. Creation of an empty client class (Done)
    7.4. Run each executable for the server and the client separately (Done)

8. Creation of an empty Diffie Hellman class (Done)

9. Add capabilities to extract the parameters p and g from the public input file (Done)
Open SSL documentation: https://docs.openssl.org/3.0/man3/DH_get_1024_160/
    9.1. Read OpenSSL Bignum documentation (Done)

10. Set the private key inside the Diffie Hellman class (Done)

Choose a cryptographically secure random a.

11. Set the public key inside the Diffie Hellman class (Done)
Compute A = g^a mod p.

12. Implement getPublicKey in the Diffie Hellman class (Done)
13. Implementation of a nonce in the client side (Done)

13. On the client side implement the sending of the public key to the server (in progress)
    
Context:
Party A (Initiator) Action:

    Choose a cryptographically secure random a.
    Compute A = g^a mod p.
    Send A to Party B.   <--- 

Example of a server response to the initial client request:
```json
{
"message_type": "server_hello",
"protocol_version": "1.0",
"session_id": "aBcDeF12345",         // Echoes client's session ID
"nonce": "serverRandomNonceValue", // Server's own unique random nonce
"diffie_hellman": {
    "public_key_B": "123456..."      // Server's public key
}
}
```
13.1. Create a valid client request to the server (done)

14. Create a shared secret on the server side (in progress)
    Send A to Party B. (Done)
    Party B (Responder) Action:

    Receive A from Party A. (Done)
    Choose a cryptographically secure random b. (Done)
    Compute B = g^b mod p. (Done)
    Compute shared secret candidate S_B = A^b mod p. (Done)
    Send B to Party A. (Done)

15. At the client side perform the following steps
    15.1. Computation of the shared secret on the client side (in progress)
        Compute shared secret candidate S_A = B^a mod p.
        Verify S_A is non-zero (i.e., not 1). If S_A is 1, it indicates a bad choice of g or a malicious attack aiming to force a trivial shared secret.
    
    15.2. Phase 2: Key Derivation and Confirmation (Crucial for Security) (Done)
        The raw shared secret S from DH is just a large number. It should never be used directly as a symmetric encryption key.

        Key Derivation Function (KDF):
        Both parties use a robust KDF (e.g., HKDF-SHA256, PBKDF2) to derive one or more session keys from the shared secret S, in this case it can be used a SHA256

16. Implement a dictionary of sessions also on the client side (Done)
17. Implement a debug flag on the Diffie Hellman class (Done)
18. Review and format the logs at the Server class (Done)
19. Review and format the logs at the Client class (Done) 
20. Review and format the logs at the DH_parameters_loader class (Done)
21. Review and format the logs at the MessageExtractionFacility class (Done)
22. Add comments to all the methods at the Client class (Done)
23. Add comments to all the methods at the DhParametersLoader class (Done)
24. Add comments to all the methods at the DiffieHellman class (Done)
25. Add comments to all the methods at the MessageExtractionFacility class (Done)
26. Add comments to all the methods at the Server class (Done)
27. Run and fix all the problems caught by the static code analysis up to this moment (Done)
28. Add get hashed secret key method to the Diffie Hellman class, for testing purpose (Done)

29. Add confirmation step on the server side (in progress)
    29.1. Add generation of random IV to the server (Done)
    29.2. Add encryption aes_256 to the encryption utility (Done)
    29.3. Add decryption aes_256 to the encryption utility (Done)
    
    29.4. Add new fields to the json response of the server (Done)
    
    ```json
    {
    "message": "Diffie Hellman keys setup successfully!",
    "sessionId": "abc123",
    "diffieHellman": {
        "groupName": "modp14",
        "publicKeyB": "..."
    },
    "nonce": "server_nonce",
    "confirmation": { // new field
        "ciphertext": "<AES-CBC or AES-GCM encrypted JSON>", // new field
        "iv": "<initialization vector>" // new field
    }
    }
    ```

30. Create an endpoint that prints all the information on the server side for each session (Done)

Endpoint URL: 
On the browser:
```bash
http://localhost:18080/sessionsData
```

31. Add a client ID to the client constructor (Done)
32. Add two more clients, meaning runClient2, runClient3 (Done)
33. Add concurrency apparat in place to deal with multiple clients (Done)

34. Create a confirmation on the client side (in progress)
