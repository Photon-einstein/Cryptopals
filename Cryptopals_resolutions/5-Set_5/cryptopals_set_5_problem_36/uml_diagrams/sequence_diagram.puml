"@startuml SRP_implementation_sequence_diagram"

box "Client Environment" #LightYellow
    participant "main (runClient1)" as Main
    participant "Client (Bob)" as Client
    participant "Client:SecureRemotePassword" as ClientSRP
    participant "Client:SessionData" as ClientSession
    participant "Client:SrpParametersLoader" as ClientSrpLoader
    participant "Client:MessageExtractionFacility" as ClientMEF
    participant "Client:EncryptionUtility" as ClientEU
end box

box "Server Environment" #LightBlue
    participant "Server (API)" as ServerAPI
    participant "Server:SecureRemotePassword" as ServerSRP
    participant "Server:SessionData" as ServerSession
    participant "Server:SrpParametersLoader" as ServerSrpLoader
    participant "Server:MessageExtractionFacility" as ServerMEF
    participant "Server:EncryptionUtility" as ServerEU
end box

activate Main

Main -> Client : Create Client("Bob", debugFlag)
activate Client

    Client -> ClientEU: getMinSaltSizes()
    activate ClientEU
        note right
            Loads the result into the _minSaltSizesMap variable
        end note
    ClientEU --> Client: A map of hash names with the minimum salt sizes, in bytes.
    deactivate ClientEU

    Client -> ClientSRP: getSrpParametersFilenameLocation()
    activate ClientSRP
        note right
            Loads the result into the _srpParametersFilename variable
        end note
    ClientSRP --> Client: Returns the SRP parameters file name location
    deactivate ClientSRP

    Client -> ClientSrpLoader : loadSrpParameters(_srpParametersFilename)
    activate ClientSrpLoader
        note right
            Loads SRP group parameters (N, g, hashName) from JSON file
        end note
    ClientSrpLoader --> Client : SRP parameters map
    deactivate ClientSrpLoader

    Client --> Main : returns Client
deactivate Client

Main -> Client : registration(client->getProductionPort(), requestedGroup)
activate Client
    Client -> Client: validate portServerNumber
    Client -> Client: registrationInit(portServerNumber, groupId)
    activate Client
        Client -> Client : built "srp/register/init" message
        note right
            Client constructs JSON registration init
            with clientId and requestedGroup
        end note
        Client -> ServerAPI : HTTP POST /srp/register/init (First message of the registration process)
        activate ServerAPI
            ServerAPI -> ServerAPI : extract client's id as extractedClientId
            ServerAPI -> ServerAPI : extract client's requestedGroup as extractedGroupId
            ServerAPI -> ServerAPI : Validate extractedClientId
            ServerAPI -> ServerAPI : Validate extractedGroupId
            ServerAPI -> ServerAPI : Get minSaltSize value
            
            ServerAPI -> ServerEU : generateCryptographicNonce(minSaltSize)
            activate ServerEU
            note right
                Loads the result into the salt variable
            end note
            ServerEU --> ServerAPI: Returns the new salt variable
            deactivate ServerEU

            ServerAPI -> ServerSession: Create SessionData(extractedGroupId, salt, hash, _debugFlag)
            activate ServerSession
                ServerSession -> ServerSession: Calls SessionData constructor
                ServerSession -> ServerSRP: Create SecureRemotePassword(debugFlag) 
                activate ServerSRP
                    ServerSRP --> ServerSession: Returns the new SecureRemotePassword
                deactivate ServerSRP
                ServerSession -> ServerSession: Validate groupId
                ServerSession -> ServerSession: Validate salt
                ServerSession -> ServerSession: Validate hash
                ServerSession -> ServerSession: Store groupId, salt and hash
                
                ServerSession --> ServerAPI: Returns the new SessionData
            deactivate ServerSession

            ServerAPI -> ServerAPI: Build JSON reply to the client 
            ServerAPI --> Client : HTTP 201 OK 
            note right
                Server constructs JSON registration init 
                response with the fields: clientId, groupId,
                groupName, primeN, generatorG, sha and salt
            end note
        deactivate ServerAPI
        Client --> Client: registrationResult
    deactivate Client

    alt registrationResult == false
        Client -> Client : Returns false
    end

    Client -> Client: registrationComplete(portServerNumber, _groupId)
    activate Client
        Client -> Client: Validation _sessionData
        Client -> ClientEU: generatePassword(_passwordSize)
        activate ClientEU
            ClientEU --> Client: Return random password
            note right
                Loads the result into the
                _sessionData->_password variable
            end note
        deactivate ClientEU
        Client -> Client: Validate password

        Client -> ClientSRP: calculateX( _hash, _clientId, _password, _salt)
        activate ClientSRP
            ClientSRP --> Client: return calculated x
            note right
                x = H(salt | H(username | ":" | password))
            end note
        deactivate ClientSRP
        Client -> Client: Stores the result at xHex

        Client -> ClientSRP: calculateV(xHex, _nHex, _g)
        activate ClientSRP
            ClientSRP --> Client: return calculated v
            note right
                v = g^x mod N
            end note
        deactivate ClientSRP
        Client -> Client: Stores the result at vHex

        Client -> Client : built "srp/register/complete" message
        note right
            Client constructs JSON registration complete
            with clientId and v
        end note
        Client -> ServerAPI : HTTP POST /srp/register/complete (Last message of the registration process)

        activate ServerAPI
            ServerAPI -> ServerAPI : extract client's id as extractedClientId
            ServerAPI -> ServerAPI : extract client's v parameter as extractedVHex
            ServerAPI -> ServerAPI : Validate extractedClientId
            ServerAPI -> ServerAPI : Validate extractedVHex
            ServerAPI -> ServerAPI : Store extractedVHex

            note right
                Server constructs JSON registration complete 
                response with a confirmation message
            end note
            ServerAPI --> Client : HTTP 201 OK 
        deactivate ServerAPI
        Client --> Client: registrationResult
    deactivate Client
    
    alt registrationResult == true
        Client -> Client : Set _registrationComplete = true
    end

    Client --> Main: registrationCompleteResult
deactivate Client

alt registrationCompleteResult == false:
    Main -> Main: throw std::runtime_error("Registration() failed.");
end

Main -> Client : authentication(client->getProductionPort())
activate Client
    Client -> Client: validate portServerNumber
    alt _sessionData == null or _sessionData->registrationComplete == false:
        Client -> Client: throw std::runtime_error("Registration is not completed.");
    end

    Client -> Client: authenticationInit(portServerNumber)
    activate Client
        Client -> Client : built "srp/authentication/init" message
        note right
            Client constructs JSON authentication init
            with clientId
        end note
        Client -> ServerAPI : HTTP POST /srp/auth/init (First message of the authentication process)
        activate ServerAPI
            ServerAPI -> ServerAPI : extract client's id as extractedClientId
            ServerAPI -> ServerAPI : Validate extractedClientId
            ServerAPI -> ServerAPI : Get groupId
            ServerAPI -> ServerAPI : Get saltSize
            ServerAPI -> ServerAPI : Get minSaltSize
            ServerAPI -> ServerAPI : Get vHex as extractedVHex
            ServerAPI -> ServerAPI : Validate saltSize
            ServerAPI -> ServerAPI : Validate extractedVHex
            ServerAPI -> ServerAPI : Get minPrivateKeyBits

            ServerAPI -> ServerSRP: generatePrivateKey(_nHex, minPrivateKeyBits)
            activate ServerSRP
                ServerSRP -> ServerSRP: Validate _nHex
                ServerSRP -> ServerSRP: Validate minPrivateKeyBits

                loop generate random candidate until n in the range [1, N-1] and at least minPrivateKeyBits
                    ServerSRP -> ServerSRP: random number generation as n
                end
                ServerSRP --> ServerAPI: privateKey
            deactivate ServerSRP
            ServerAPI -> ServerAPI: Store privateKey as _privateKeyHex

            ServerAPI -> ServerAPI: getIsServerFlag
            activate ServerAPI
                ServerAPI --> ServerAPI: isServer
            deactivate ServerAPI

            ServerAPI -> ServerSRP: calculatePublicKey(_privateKeyHex, _nHex, gHex, isServer, k, _vHex)
            activate ServerSRP
                ServerSRP -> ServerSRP: Validate _privateKeyHex as b
                ServerSRP -> ServerSRP: Validate _nHex as N
                ServerSRP -> ServerSRP: Validate gHex as g
                ServerSRP -> ServerSRP: Validate k
                ServerSRP -> ServerSRP: Validate vHex as v

                ServerSRP --> ServerAPI: return calculated B
                note right
                    B = (k*v + g^b) mod N
                end note
            deactivate ServerSRP

            note right
                Server constructs JSON authentication init 
                response with a confirmation message with the
                fields: clientId, salt, B, groupId
            end note
            ServerAPI --> Client : HTTP 201 OK 
        deactivate ServerAPI

    deactivate Client

    alt registrationResult == false
        Client -> Client : Returns false
    end

    Client -> Client: authenticationComplete(portServerNumber)
    activate Client

    deactivate Client


deactivate Client


Main -> Main : Program ends
deactivate Main

@enduml